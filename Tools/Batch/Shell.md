# Shell脚本

### 操作系统内存管理

内核通过硬盘上的存储空间来实现虚拟空间（交换空间），

> 内核通过不断在交换空间和实际的物理地址之间反复的交换虚拟内存中的内容，使得系统认为他拥有比实际上更多的可用的内存
>
> 内核通过记录内存页面是使用情况，比自动把长时间未使用的内存页面赋值到交换空间的区域（这个操作会拖慢进程）



### 软件程序管理

内核创建第一个进程（`init`）来启动系统上的其他进程，它会将 `init` 加载到虚拟内存中，内核启动进程时候，会在虚拟内存中给新的的进程分配一块专有的区域来存储数据和代码



##### 链接文件

- 符号链接

  - 另一个真实的文件，两个文件通过符号链接在一起，彼此的内容并不相同

  > 要为一个文件创建符号链接，原始文件必须存在
  >
  > `ln -s` 来创建符号链接
  >
  > 可以通过查看 `inode` 编号来判断，是否为独立文件

- 硬链接

  - 会创建独立的虚拟文件，其中包含原始文件的信息和位置，更本上来说是同一个文件
  - 创建硬链接，源文件也必须存在，只不过不需要添加额外的参数

  > 复制链接文件注意：
  >
  > 使用 `cp` 命令复制文件，该文件已经被链接到另一个源文件，那么得到的是一个源文件的副本（可以通过创建源文件的另一个链接）
  >
  > 尽量避免创建软链接文件的软链接（产生混淆链）



##### 重命名

`mv`

只影响文件名，但是 `inode` 编号和时间戳不变



##### 删除

`rm`



### 处理文件目录

- `mkdir`
  - 创建文件
- `rmdir`
  - 删除文件，只能删除空目录



### 查看文件

##### `file`

探测文件的内部，并决定文件的类型（文件信息，字符编码）



### 查看整个文件

- ##### `cat`

- ##### `more`

- ##### `less`

  - `more` 的升级版



### 查看部分文件

- `tail`
  - 显示文件最后几行，默认情况下显示最后 `10` 行
- `head`
  - 查看文件头部



# 监测程序



### 探查程序

- `ps`

  - 探查进程，只会显示运行在当前控制台下的属于当前用户的进程

  > 只能显示某个特定时间的信息

- `top`

  - 和上面命令相似，能够实时显示进程信息

- `kill`

  - 可以通过进程 `ID` 给进程发信号

  > 因为只能使用 `PID` 不使用命令名，一般 `kill` 不常用

- `killall`

  - 支持进程名而不是 `PID` 来结束进程，支持使用通配符



### 检测磁盘空间

- `mount`

  - 挂载目录，提供以下信息
    - 媒体设备文件名
    - 挂载到虚拟目录挂载点
    - 文件系统类型
    - 已挂载媒体的访问状态

  > 在使用手动挂载设备时，需要使用 `root` 用户的身份登录
  >
  > `mount -t type device directory`
  >
  > `type` 需要指定磁盘被格式化的文件系统类型

- `umount`

  - 移除一个设备不能直接将设备移除，应该先卸载设备

- `df`

  - 查看设备上磁盘空间的剩余量

- `du`

  - 显示特定目录下的磁盘使用情况



### 处理数据文件

处理大量数据一个常用命令是 `sort`



### 搜索数据

在输入或者指定的文件中包含匹配指定模式的字符的行

> `-v` 进行反向搜索，输出不匹配该模式的行



### `Shell` 父子关系

当一个 `Shell` 创建一个新的 `Shell` 时，该新的 `Shell` 被称为子 `Shell`

> 可以使用命令行参数修改 `Shell` 启动方式
>
> 使用环境变量判断是否生成子 `Shell` `echo $BASH_SUBSHELL`

> 在 `Shell` 脚本中，经常使用 `Shell` 进行多线程的操作（明显拖慢处理的速度）



### 命令行列表

一行中指定要依次运行一系列的命令，使用 `;` 分隔

##### 进程列表

需要使用 `()` 成为进程列表

> 使用 `()` 可以生成一个子 `Shell` 来执行对应的命令



### 子 `Shell` 用法

##### 后台模式

在后台模式中运行命令可以在处理命令同时让出 `CLI`

> `sleep` 是一个经典的后台模式使用，使用 `&` 将命令置入后台模式
>
> 可以使用 `ps` 或者 `jobs` 命令来显示后台作业信息
>
> 后台模式作业结束的状态可能忽然出现在屏幕上



### 协程

协程可以同时做两件事，它在后台生成一个子 `Shell`，并且在这个子 `Shell` 里面中执行命令

`coproc` 用来进行协程处理

> 除了创建 子 `Shell` 之外，协程基本上就是将命令置入后台模式



### 内建命令

外部命令，有时也被称为文件系统命令，不是 `bash shell` 程序，`ps` 就是一个外部命令，可以使用 `which` 或者 `type` 命令去查找

> 当外部命令执行时，会创建一个子进程；这种操作被称为衍生 `forking` 
>
> 当进程必须执行衍生操作时，需要花费时间等来设置新子进程的环境



内建命令区别于外部命令的一点是不需要使用子进程来实现



### `history`

内建的一个命令，`bash shell` 通过追踪之前使用过的命令，可以唤回这些命令并重新使用

如果打开多个终端会话，可以使用 `history -a`  在打开的会话中向 `.bash_history` 文件中添加记录

> 对于其他打开的终端会话，历史记录不会自动更新，可以使用 `history -n`



### `alias` 

别名，另一个内建命令

`alias -p` 查看全部别名



### `!!`

唤回之前使用过的命令再使用

> 命令的历史是存放在 `.bash_history`，历史记录先是存放在内存中的，当 `Shell` 退出之后才被写入历史文件中





# `Linux` 环境变量

用来存储关于 `shell` 的会话和工作环境信息，允许在内存中存储数据



### 全局变量

对于 `shell` 中的所有会话和子 `shell` 都可见

##### 查看全局变量

`env` 和 `printenv`

`printenv` 还可以用来查看个别环境变量

`echo $[name]` 显示个别值



##### 创建全局变量

先创建一个局部变量，然后导出到全局变量中（`export`）

> 修改子 `shell` 中的全局变量，并不会影响父 `shell` 中的全局变量
>
> 子 `shell` 中使用 `export` 也无法改变父 `shell` 中的值



### 局部变量

只对创建它的子 `shell` 可见



##### 设置用户定义变量

设置局部用户定义变量

一旦启动 `bash shell` (或者执行一个 `shell` 脚本) ，就能创建在这个 `shell` 进程内可见的局部变量，可以通过等号进行赋值

定义的局部变量用小写，系统变量使用大写字母

> 变量名、等号和值之间没有空格，如果有会把值当作一个单独的命令
>
> 局部环境变量无法在子 `shell` 中使用，退出子 `shell` 之后仍然可以使用



### 删除环境变量

使用 `unset` 命令

> 使用 `unset` 命令中引用环境变量不要使用 `$`
>
> 一般情况下，要使用环境变量时使用 `$`, 操作环境变量时不使用；除了 `printenv`



### 设置 `PATH` 环境变量

当输入一个外部命令时，`shell` 必须搜索系统来找到对应的程序；`PATH` 环境变量定义用于进行命令和程序查找的目录

> 如果命令或者程序的位置没有包括在 `PATH` 变量中，不使用绝对路径，`shell` 无法找到
>
> 通常将 `.` 加入 `PATH` 环境变量；表示当前目录
>
> 对 `PATH` 变量的修改只能持续到退出或者重启系统



### 系统环境变量

启动 `bash` 时，会在文件中查找命令；这些文件叫做启动文件或者环境文件

- 登录时作为默认登录 `shell`
  - `.bashrc` 通常会通过其他文件进行启动；`.bash_profile` 启动文件会先检查 `HOME` 目录是否存在 `.bashrc` 的启动文件；如果有先执行启动文件里面的命令
- 作为非登录 `shell` 交互式
  - 通常不会访问 `/etc/profile` 只会检查用户 `HOME` 目录中的 `.bashrc` 文件
- 运行脚本的非交互 `shell`
  - 执行 `shell` 脚本时使用的 `shell`
  - 使用 `BASH_ENV` 环境变量



### 登录 `shell`

- `/etc/profile`
  - 默认主启动文件，每个用户登录时都会执行
- `$HOME/.bash_profile`
- `$HOME/.bashrc`
  - 查看 `/etc` 目录下通用的 `bashrc` 文件
  - 提供定制命令别名
  - 私有脚本函数

- `$HOME/.bash_login`
- `$HOME/.profile`

> 有些 `Linux` 发行版本使用了可拆卸认证模块（Pluggable Authentication Modules，PAM）
>
> 发行版本的 `Linux` 一般只有这些文件里面的一到两个；按照顺序读取，其余的将会被忽略掉

大部分应用都会创建两个启动文件

- `.sh`
  - 提供给 `bash shell` 使用

- `.csh`
  - 给 `cshell` 使用

  

### 环境变量持久化

可以修改 `/etc/profile` 文件，但是一旦发行版升级之后可能导致之前设置过的环境变量消失

最好是在 `/etc/profile.d` 目录中创建一个以 `.sh` 结尾的文件，把所有修改过的全局环境变量放在里面

一般情况下，存储用户永久性 `bash shell` 变量的地方是 `$HOME/.bashrc`

> 如果设置了 `BASH_ENV`，除非指向 `$HOME/.bashrc` 否则将非交互式的 `shell` 用户变量放到别的地方



### 数组变量

环境变量可以作为数组使用

```
my=(1 2 3)
echo ${my[index]}
```

> 显示整个数组可以使用 `*` 通配符来实现



# 文件权限



### 安全性

权限是通过创建用户时分配给用户的 `ID`，`UID` 来进行追踪的

> 登录系统时用的不是 `UID` ，而是登录名



##### `/etc/passwd` 

使用专门的文件将用户的登录名匹配到对应的 `UID` 上



`Linux` 系统会为各种功能创建不同的用户账户，这些账户不是真正的用户

系统账户是系统运行各种功能创建的不同的特殊账户

> 运行在后台的服务需要用一个系统用户登录到 `Linux` 上
>
> `Linux` 为系统账户预留了 `500` 以下的 `UID`，有些服务需要使用特定的 `UID` 才能正常工作



### `/etc/shadow`

绝大多数 `Linux` 系统将用户密码单独保存此文件中，只有特定的程序去打开（登录）



### 管理文件系统

##### `ext` 文件系统

提供一个基本的类 `Unix` 系统：使用虚拟目录来操作硬件设备，在物理设备上按定长的块来存储数据

使用索引节点的系统来存储文件信息

索引节点系统在每个物理设备中创建一个单独的表（索引节点列表）用来存储文件的信息

> 文件大小不超过 `2GB`

##### `ext2` 文件系统

保持和 `ext` 相同的结构，扩展了索引节点表的格式用来保存更多的信息（创建时间，修改时间和最后访问时间）

改变文件在数据块中存储方式

> `ext` 文件存储数据很容易导致碎片化，碎片化会导致文件系统性能降低
>
> `ext2` 通过采用按组分配磁盘块来减轻碎片化，通过分组不需要查找整个磁盘；允许将最大文件加到 `2TB`



##### 日志文件系统

为 `Linux` 系统增加一层安全性，不再使用先将数据直接写入存储设备再更新索引节点表的方式；将文件更改写入临时文件

数据成功写入存储设备和索引节点表之后，再删除对应的日志条目

> 如果系统在数据被写入存储设备之前崩溃或者断电，日志文件系统会读取上次留下的未写入的数据

##### 日志方式

- 数据模式
  - 索引节点和文件写入日志；风险低，性能差
- 有序模式
  - 只有索引节点数据写入日志，数据写成功之后删除
- 回写模式
  - 只有索引节点数据写入，不控制文件数据何时写入；容易丢失数据

> 数据模式日志最安全的数据保护方法，同时也是最慢的；每一份数据需要写两遍



##### `ext3` 文件系统

大部分 `Linux` 发行版本的默认文件系统，采用和 `ext2` 相同的索引节点表，但是给每个存储设备增加了一个日志文件

> 默认情况下使用有序模式日志功能



##### `ext4` 文件系统

支持数据压缩和加密功能，支持区段特性

区段：在存储设备上按块分配空间，但是索引节点表中只保存起始块的位置

块预分配技术，使用 `0` 填满预留的数据块，不会将他们分配给其他文件



##### `Reiser` 文件系统

只支持回写日志模式，把索引列表数据写到日志文件

> `ReiserFS` 称为 `Linux` 上最快的日志文件系统
>
> 可以调整已有的文件大小；尾部压缩 



##### `JFS` 文件系统

最老的日志文件系统，采用有序日志方式

采用基于区段的文件分配，为每个写入存储设备的文件分配一组块



##### `XFS` 

类似于 `ReiserFS` 文件系统，除了 `XFS` 文件系统只允许扩大不能缩小



### 写时复制文件系统

对文件系统而言，日志式的另一种选择是一种叫做写时复制的技术（COW）



##### `ZFS` 文件系统

##### `Btrf` 文件系统



# `Shell` 脚本部分



### 变量

`shell` 维护一组环境变量，用来记录特定的系统信息，可以使用 `set` 命令显示一份完整的当前环境变量的列表

使用 `$` 来引使用这些环境变量

##### 命令替换

从命令中提取数据，赋值给变量

- ` `` ` 
- `$var`

> 命令替换会生成一个子 `shell` 来运行对应的命令
>
> 在命令行提示符下使用路径 `./` 运行命令，也会创建子 `shell`



### 重定向输入和输出

管道

管道串连起来的命令不会依次执行，实际上是同时运行这两个命令的



### 数学运算

`expr`

要将数学算式的结果赋值给一个变量，需要使用命令替换来获取 `expr` 命令的输出

使用 `$[operation]`

对于浮点数的运算，它是由内建的 `scale` 控制的，必须设置希望保留的小数位数

> scale 默认值为 `0`

如果想要在脚本中使用 `bc` ，可以使用命令替换的功能

```shell
var=$(echo "scale=4; 3.44 / 5" | bc)
```



### 退出脚本

##### 查看退出状态码

`$?` 用来保存上个已执行命令的退出状态码



### 结构化命令

`if-then`

```shell
if command
then
	command
fi
```

> `bash` 后面的 `if` 语句会运行 `if` 后面的命令，如果该命令的退出状态码是 `0` ，位于 `then` 部分的命令就会被执行
>
> `if-then` 无法测试退出状态码以外的条件



##### 双括号

允许在比较过程中使用高级的数学表达式，`test` 命令只支持基础的数学运算

也可以用来给脚本里面的普通命令进行赋值



##### 双方括号

提供针对字符串比较的高级特性：

可以使用 `test` 命令中采用的标准字符串比较，同时提供了新的特性——模式匹配

模式匹配：

可以定义一个正则表达式来匹配字符串的值

> 不是所有的 `bash` 支持使用



### `test` 命令

可以更好的辅助 `if-then` 的使用，如果 `test` 命令中的条件成立，`test` 命令退出并返回退出状态码 `0`

- `test condition`
- `if [ condition ]`

> 两个方括号之间必须增加一个空格



##### 数值比较

```shell
num -eq num
```

> `test` 命令中无法使用浮点值



##### 字符串比较

```
str = str
str != str
str < str

-n str	# 长度是否非零
-z str	# 长度是否为零
```



##### 文件比较

允许测试 `Linux` 文件系统上文件和目录的状态

- 检查目录

  - `-d`

- 检查对象

  - `-e`

  > 可以用于文件和目录；要确定指定的对象为文件，必须使用 `-f`

- 检查文件所属关系

  - `-O`

- 检查默认属组关系
  - `-G`



### 复合条件测试

使用布尔值来辅助测试

- `&&`
- `||`



### `case`

不需要使用 `if-then` 检查，比较变量寻找到特定的值

`case` 变量采用列表格式来检查单个变量的多个值

```shell
case variable in 
pattern1 | pattern2) commands1;; 
pattern3) commands2;; 
*) default commands;; 
esac
```

将指定的变量和模式进行匹配



### `for` 命令

允许创建一个遍历一系列值的循环

```shell
for var in list 
do 
 commands 
done
```

> `list` 提供迭代中要用到的一系列的值



### 读取复杂值

`shell` 看到列表值里面的单引号可能会尝试用它们来定义一个单独的数据类型

- 使用转义字符（反斜线）来转义
- 使用双引号来定义用到的单引号的值



### 更改字段分隔符

特殊的环境变量 `IFS`，叫做内部字段分隔符

默认情况下的分隔符：

- 空格
- 制表符
- 换行符

> 使用换行符作为分隔符	`IFS=$'\n'`
