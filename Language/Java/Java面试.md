# 基础

switch 支持可以隐式转换为 int 的类型，这些类型的包装类也可以。switch 不支持 long



short s1=1; s1 = s1 + 1; 错误，运算时会自动提升表达式类型；s1+=1 正确，java 会对表达式进行特殊处理



最有效率算出 2 乘 8 等于几，2 << 3



静态内部类无法引用



String 类是 final 类型，因此不可以继承。为了提高效率节省空间，我们应该使用 `StringBuffer`



`Thread.stop()`

​	会立刻停止该线程，释放所有该线程获取的锁，可能导致数据不一致或者资源泄露

`Thread.suspend()`

​	线程挂起但是不释放锁，挂起的线程永远不会释放他们

`Thread.resume`

​	难以恢复一致性

`Thread.sleep`

​	线程暂停执行，给其他线程机会，等时间到了恢复执行

`wait`

​	本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出 `notify`

​	

### 多线程

实现方式

- 继承 Thread 或者 Runnable
- 同步 synchronize，wait 和 notify

静态方法和非静态方法之间的同步

- 静态方法使用的是类级别的锁，该类的 `class` 对象



`Lock` 可以实现 `synchronize` 所有功能，拥有更好的性能。`Lock` 不会自动释放锁，必须要在 `finally` 里面手动释放。`tryLock()` 可以以非阻塞的方式拿到锁





设计一个百亿的计算器，计算机中用固定数量的字节来存储数据的值，`byte` 类型的整数，`-128 ~ 127` 计算机的算术运算符不能超过该类型的数值范围

- 类内部有两个成员变量
  - 符号位
  - 字节数组
- 包含多位数的字符串转到内部符号和字节数组中
- 提供加减乘除的功能



面向对象特征

- 封装
  - 高内聚低耦合，把对象的描述封装到一个类
- 继承
  - 共享父类数据和方法
- 抽象
  - 找出共同之处
- 多态
  - 程序运行时候才能确认引用变量指向哪个对象





使用  `redis` 存储手机验证码（SMS验证码）

- 惰性删除
  - 客户端访问一个键，`redis` 才会检查该键是否会过期。

- 执行过程
  - 如果键已经过期，在响应之前删除
  - 每次定期删除操作会限制最大执行时间和频率
- 积极的回收内存，防止过多的过期键堆积



定期删除

- 按照配置的时间间隔，扫描一部分可能过期的键
- 执行过程
  - 随机选择一些设置过期时间的键



`RDB`

快照式持久化，指定时间点创建内存所有数据的一个二进制快照，并将其写入磁盘

- 优点
  - 文件紧凑，适合备份
  - 恢复速度快
- 缺点
  - 如果两次快照之间发生故障，丢失最后一次快照机会



三个问题

- 缓存穿透
  - 查询数据不在缓存或者数据库中
- 缓存击穿
  - 某个热点数据突然过期，大量请求同时尝试重建这个缓存
- 缓存雪崩
  - 大量缓存同时过期



### `ArrayList` 和 `Vector`

两个类都实现了 `List` 接口都是有序的，可以使用索引去查询数据.

- 同步性
  - `Vector` 是线程安全的，方法是线程同步的，`ArrayList` 线程是不安全的
- 数据增长
  - `Vector` 数据增长一倍，并且可以自主设置增长数量。`ArrayList` 增加 0.5 无法设置增长倍数



`HashMap` `Hashtable`

- `HashMap` 不是线程安全的	



`Java` 序列化



垃圾回收机制

当我们创建对象的时候，`GC` 就开始监控这些对象

内存泄漏

长生命周期的对象持有短生命周期的对象，加载一个对象放在缓存里面



`stream` 是什么

遍历数据集合的高级迭代器，只能遍历一次。数据源不会被修改

- 不可重复消费
- 不可修改数据源



### `CountDownLatch`

一次性的



### `ThreadLocal` 导致的内存泄露

`ThreadLocal` 不存储对象，真正的存储是靠 `ThreadLocalMap` 类

- 每一个线程都有一个 `Thread` 实例，其内部有一个 `threadLocals` 的实例成员
- 通过实例化 `ThreadLocal`，可以设置一些线程私密的变量，`set` 和 `get` 来存取
- 最终结果存储在`ThreadLocalMap` 里面，`ThreadLocal` 只是作为键
- 使用场景
  - 存储线程私有变量
  - 实现线程安全的变量
  - 减少线程资源竞争

> 使用完 `ThreadLocal` 之后，调用 `remove` 删除数据



### 强引用和弱引用

强引用存在，GC 永远不会回收掉被引用的对象

弱引用，回收就会死亡，存活到下一次垃圾回收

软引用，发生内存溢出之前，会把这些对象列入二次回收范围，回收之后如果没有足够的内存，会抛出内存泄漏

虚引用，被回收之前通知一下



### `volatile`

一个共享变量被修饰，会保证修改的值立即被更新到内存中

synchronize，lock 保证同时只有一块代码在执行



### 活跃度问题

死锁

- 环形等待锁导致线程死锁

活锁

饥饿

性能问题

- 创建线程
- 线程切换



### 悲观锁

每次操作共享数据的时候都会加锁



### 乐观锁

操作数据不会不会上锁，更新数据的时候才会去判断是否有其他线程操作数据



### 公平锁



### 非公平锁



### 可重入锁

一个线程外部获取锁内部也会自动获取锁



### 自旋锁

线程在没有获得锁时候不会被挂起，而是执行一个忙循环，减少线程被挂起的可能性



### Java线程与主内存的关系

1. 所有变量存储在主内存中
2. 每个线程都有一个私有的本地内存，存储需要读写变量的副本
3. 线程对于变量的所有操作必须在本地内存中进行
4. 不同的线程之间无法直接访问对方本地内存中的变量



八种内存操作

- 锁定
- 解锁
- 读取
- 载入
- 使用
- 赋值
- 存储
- 写入



CAS 基本原理

原子性操作，比较并交换

- ABA 问题
  - 一个变量初始值为 A，修改 B，然后又修改 A。
  - 引用没有变，包含的实际变量已经发生改变；（可以在变量前添加版本号）
- 自旋开销问题
  - CAS 冲突之后会开始自旋操作，如果资源竞争很激烈会给 CPU 带来很大的竞争
  - 限制自旋的次数，或者自旋延迟执行
- 只能保证单个变量的原子性
  - 如果同时对多个变量进行操作就不行。
  - `synchronized` 进行加锁。`AtomicReference` 来保证引用对象之间的原子性



### `Atomic`

- 原子操作基本类型
- 原子操作数组类型
- 原子操作引用类型
- 原子操作更新属性

核心功能为 `CAS` 操作，如果 `CAS` 失败会循环进行重试。因为核心操作是使用操作系统的机制，只适合一些小型的操作，对于复杂的处理还是建议使用锁

`LongAdder` 运行效率更高。



### `Java` 内存模型

- 缓存一致性的问题

  - 主存和处理器之间运算速率存在差距，引入高速缓存来解决这个问题，但是带来另一个问题缓存一致性
    - 多 CPU 系统或者多核，大家都有自己的高速缓存，共享同一个主内存，可能导致各自缓存中数据不一致

- 处理器优化和指令重排

  - 为了使得处理器内部的运算单元最大程度的被利用，处理器对代码进行乱序处理

  > - 不改变单线程语义的情况下，重新安排语句的执行顺序
  > - 指令集并行，将多条指令重叠执行
  > - 内存系统重排序。

- 对应虚拟机为

  - 可见性
    - 缓存一致性
  - 原子性
    - 处理器优化
  - 有序性
    - 指令重排序

- 解决办法

  - 限制处理器优化
  - 使用内存屏障



`Java` 线程和主内存的关系

- 所有的变量存在主内存中
- 每个线程都有私有的本地内存，存储该线程需要读写的变量
- 不同线程之间无法直接访问对象内存



### 注解

- 注解体
- 注解变量
  - 注解变量的语法类似于接口里面定义的方法	
- 元注解
  - `Target` 注解
    - 描述注解的范围
  - `Retention` 注解
    - 注解的生命周期
  - `Document` 注解
    - 用来描述使用 `javadoc` 工具类生成帮助文档时是否保留其注解信息
  - `Inherited` 注解
    - 表示该注解是否具有继承性





### `Kafka`

随机读写和顺序读写

- 读取第一个 `block`时，要经历寻道，旋转延迟和数据传输才能读取完这个数据，读取下一个 `block` 也需要经历一下的步骤
- 下一个读取的`block` 正好在下一个扇区

- 顺序读写
- 使用 `MMAP` 将磁盘和内存进行映射
- 使用`DMA` 实现零拷贝，减少数据传输次数
- 读数据时候配合 `sendfile` 暴力传输，批量压缩传输文件

传递的三个步骤

- 生产者发消息给 `Kafka Borker`
  - 生产者与 `leader` 直接交互，先从集群获取对应分区的 `leader` 元数据
  - 获取 `leader` 分区元数据后直接将消息发过去
- `Kafka Broker` 消息同步和持久化
- `Kafka Broker` 将消息传递给消费者
