# Shell

Shell是命令解释器，用于解释用户对操作系统的操作



#### Linux的启动过程

- `BIOS`
- `MBR`
  - 主引导记录
- `BootLoader(grub)`
- `kernel`
- `systemd`
- 系统初始化
- `shell`

# Shell  脚本	

1. ##### `bash`声明（Sha-Bang）

2. ##### 命令

3. ##### `#`开头的注释

4. ##### 赋予可执行权限 `chomd u+x filename` 

5. 执行命令

`#!/bin/bash`	

- `bash filename.sh`
  - 使用 `bash` 来解释运行脚本文件
- `./filename.sh`
  - 执行脚本时必须保证脚本拥有执行权限
  - 使用默认的命令解释器来运行脚本

> 如果执行shell脚本文件，如果运行`cd`命令不会影响当前运行环境（运行时产生一个新的子进程），下面两个命令会影响

- `source ./filename.sh`
- `.filename.sh`



### 内建命令和外建命令

- 内建命令不需要创建子进程
- 内建命令对当前 shell 生效



# 管道和重定向

### 管道与管道符

管道和信号都是进程的通信方式

匿名管道（管道符）是 shell 中经常到的通信工具

管道符`|`，将前一个命令的执行结果传递给第二个命令

### 子进程和子shell

### 重定向符号

输入输出和文件建立连接	

一个进程默认会打开标准输入，标准输出和错误输出三个文件描述

- 输出重定向 `<`
- 输入重定向 `>` `>>` `2>` `&>`
  - `2>`
    - 错误重定向，如果当前命令产生错误，将错误信息输入到指定文件
  - `&>`
    - 无论结果是正确还是错误的将信息输入到指定文件中	
- 输出重定向和输入重定向组合使用	





# 变量

##### 变量的定义

- 字母、数字、下划线
- 不可以以数字开头

##### 变量的赋值

- 变量名=变量值

  - ```bash
    a=0
    ```

- 使用`let`为变量赋值

  - ```bash
    let a=0
    ```

- 将命令赋值给变量

  - ```bash
    l=ls
    ```

- 将命令的结果赋值给变量，使用`$()` 或 ` `` `

  - ```bash
    let a=$(ls -l /etc
    ```

> 变量赋值时中间不能使用空格分割
>
> 变量中有空格等特殊字符可以包含在 `""` 或 `''`



##### 变量的引用

- `${变量名}`
  - 对变量的引用
- `echo ${变量名}`
  - 查看变量的值	
- `${变量名}`
  - 部分时候可以写作`$变量名`

##### 变量的默认作用范围

- 变量的导出
  - `export`
  - 使得子进程获得父进程的变量信息
- 变量的删除
  - `unset`

> 变量的作用范围为当前进程，执行含有变量的 shell 的脚本，使用`bash filename.sh`可能无法运行，使用`source filename.sh`



##### 系统的环境变量

每个shell打开获得的变量	

- `set` `env`

  - `env` 
    - 查看已经设置的默认的环境变量

- `$?` `$$` `$0`

  - `$?`
    - 上一条命令是否正确执行
  - `$$`
    - 获取当前进程的`PID`
  - `$0`
    - 当前进程的名称	

- `$PATH`

  - 命令的搜索路径

- `$PS1`

- 位置变量

  - `$1` `$2` ……

  - 选项参数

  - ```bash
    echo {$2}_
    # $2如果为空读入下划线
    ```




##### 环境变量配置文件

- `/etc/profile`
- `/etc/profile.d`
- `~/.bash_profile`
- `~/.bashrc`
- `/etc/bashrc`

> 加载顺序为：`/etc/profile`，`~/.bash_profile`，`~/.bashrc`，`/etc/bashrc`，如果产生冲突的话，后面脚本内容会替换前面的脚本文件
>
> 为命令搜索路径增加：`export PATH=$PATH:/new_path` 



# 转义和引用

### 特殊字符

- `#`
  - 注释
- `;`
  - 分号
- `\`
  - 转译符号
- `"` `'`
  - 引号

### 转义符号

- 单个字符前的转义符号
  - `\n` `\r` `\t`
    - 单个字母转义
  - `\$` `\"` `\\`
    - 单个非字母的转义

### 引用符号

- `"`
  - 双引号——对变量解释
- `'`
  - 单引号——不会对变量解释
- `
  - 反引号	



### 运算符

- 赋值运算符

  - `=`

  - 算数赋值和字符串赋值

  - 使用`unset`取消赋值

  - > `=`还可以作为测试操作符

- 算数运算符

  - `+ - * / ** %`

  - 使用 `expr` 进行运算

    - > 只支持整数，不支持浮点数

- 数字常量

  - `let "变量名=变量值"`
  - 变量值使用`0`开头为八进制，`0X`为十六进制

- 双圆括号

  - 简化`let`赋值
  - `((a=10))`



### 	数组

- 定义数组
  - `IPTS=( 10.0.0.1 10.0.0.2 10.0.0.3)`
- 显示数组中的全部元素
  - `echo ${IPTS[@]}`
- 显示数组元素的个数
  - `echo ${#IPTS[@]}`
- 显示数组中的第一个元素
  - `echo ${IPTS[0]}`



### 特殊符号的使用

##### 括号

- `() (()) $()`

  - 单独使用圆括号会产生一个字`shell`

  - > 在子shell里面的进行赋值的语句在父进程里面无法被读取到

- `[] [[]]`

  - 单独使用方括号是测或是数组元素的功能
  - 两个方括号表示测试表达式

- `<>`

  - 尖括号；重定向符号

- `{}`

  - 输出范围
    - `echo {0..9}`
  - 文件复制
    - `cp -v /etc/passwd{,.bak}`



> 相关命令的简写形式
>
> `test —— []` 使用`[[]]`中允许使用真正的运算符号`<,>,*……` 
>
> `let (())`





##### 运算符和逻辑符号

- 算术运算符
  - `+ - * / %`
- 比较运算符
  - `> < =`
- 逻辑运算符
  - `&& || !`

##### 转义字符

- `\`转义某符号	
  - `\n` 普通字符转义之后实现不同的功能
  - `\'` 特殊字符转义之后当作普通的字符来使用



##### 其他符号

- `#`

  - 注释符号

- `;`

  - 命令分割符号

  - > 注： `case`语句的分隔符号要写作为`;;`，使用第一个`;`转义第二个分号

- `:`

  - 空指令

- `.` 

  - 实现的功能等同于`source`指令

- `~`

  - 家目录

- `,`

  - 分隔目录

- `*`

  - 通配符

- `?`

  - 条件测试 或 通配符

- `$`

  - 取值符号

- `|`

  - 管道符号

- `&`

  - 后台运行

- `_`

  - 空格 



# 测试与判断

### 退出程序的命令

- `exit`
  - 返回非0为不正常退出
- `$?`
  - 判断当前 shell 前一个进程是否正常退出



### `if-then`

```bash
if [测试语句成立] 或 命令的返回值是否为0
then 执行命令
fi	结束判断
```



`if-then-else`

```bash
if [测试语句成立] 或 命令的返回值是否为0
then 执行命令
elif [测试条件]
then 执行命令
else 如果上述条件不成立执行这一条语句
fi	结束判断

# 嵌套使用 if 判断
if [测试条件成立]
then 执行命令
	if [测试条件成立]
	then 执行命令
	fi
fi 结束
```



### 分支（case）的使用

`case` 和 `select` 可以构成分支

```bash
case "$变量" in
 	"情况1" )
 	命令...;;
 	"情况2" )
 	命令...;;
 	* )
 	命令...;;
 esac
```



### 循环

##### `for`循环使用

```bash
for 参数 in 列表
do 执行命令
done 封闭循环

# C语言风格的 for
for((变量初始化;循环判断条件;变量变化))
do
	循环命令
done
```

> 使用反引号 或 `$()` 方式执行命令，命令的结果当作列表进行处理

##### 使用`for`循环遍历变量和文本

- 列表中包含多个变量，变量使用空格分割
- 对文本处理，要使用文本查看命令取出文本的内容
  - 默认逐行处理，如果文本出现空格会当作多行处理



##### `while`循环

```bash
while test 测试成立
do 	
	命令
done
```

##### `until`循环

`until`循环和`while`循环相反，测试条件为真时停止

##### 使用循环处理命令行参数

- 命令行参数可以使用`$1 $2 $3 $4 ${10}……$n`
- `$0`代表脚本名称
- `$*` 和 `$@` 代表所有位置的参数
- `$#` 代表位置参数的数量



### 使用循环处理位置参数

- `shift`参数
  - 每次执行之后对参数进行减法操作	





### 函数

函数用于包含重复使用命令的集合

```shell
function fname(){
	cmd
}
```

> 为了防止函数内的参数对于函数范围外的变量产生影响，可以使用 `local`关键字定义函数中的变量为局部变量



##### 系统脚本库

- `/etc/init.d/functions`

##### 自建函数库

- 使用 `source` 命令导入	



### 脚本优先级控制

调整脚本优先级

`nice` 和 `renice` 调整脚本的优先级

> 防止出现不可控的死循环，（占用大量资源的死循环 / 创建大量子进程）



### 捕获信号

- `kill`进程
  - 默认发送 15 号信号给应用程序
- `ctrl + c` 
  - 发送 2 号信息
- `9`
  - 信号不可以阻断

```shell
trap "echo 	sig 15" 15
# 捕获 15 号信号
```



### 计划任务

- 一次性计划任务
  - `at`

```shell
at [time] [cmd] <EOF>
# 按Ctrl + D告诉终端注册所谓的EOF（文件结尾），即输入流结束
```

> 使用该方式输入的命令要保证`$PATH`中是否有命令的执行路径，如果没有需要添加命令的完整路径 或 使用 `source` 命令
>
> 该条命令无法直接输出打印，需要使用重定向输出到指定的文件
>
> `atq`	查看一次性任务执行的队列

- 周期性计划任务

  - `cron`

    - 配置方式

      - `crontab -e`

    - 查看现有的计划任务

      - `crontab -l`

    - 配置格式

      - 分钟 小时 日期 月份 星期 执行的命令

        > 注意：命令的路径的问题

    ```bash
    crontab -e
    -----------vim--------
    * * * * * * /usr/bin/date >> /tmp/.txt
    ```

    > `/var/log/cron`

- 计划任务加锁

  - 周期性计划任务可能出现有特殊情况无法按时完成，使用延时计划（`anacrontab`）
    - 配置文件目录 
      - `/etc/cron.d/0hourly`
      - `/etc/anacrontab`

```bash
01 * * * * root run-parts /etc/cron.hourly
# run-parts 开机检查一次确保该脚本以及被使用过
```



- `flock`

文件在同一时间只能运行一个

```shell
flock -xn "/tmp/f.lock" -c "/root/a.sh"
# 排查锁，只能运行一次
```



