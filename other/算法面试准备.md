# 算法面试准备

快速排序算法 `O(nlogn)`

##### 数据存在的特征

- 包含大量重复元素
  - 三路排序
- 数据是否近乎有序——银行按时间排序
  - 插入排序
- 数据的取值范围有限——学生成绩
  - 计数排序

##### 要求

- 稳定性
  - 归并排序



##### 算法优化的思路

- 遍历常见的算法思路 
- 遍历常见的数据结构
- 空间换时间（哈希表）
- 预处理（排序）



### 算法时间复杂度

算法的时间复杂度通常是看最差情况来决定的

算法复杂度是用来表示算法性能变化趋势的，所以常数值不重要



### 数据规模的概念

如果想在 `1s` 内解决问题

- `O(n^2)` `10^4`级别数据
- `O(n)` `10^8` 级别数据
- `O(nlogn)` `10^7` 级别数据



##### 循环不变量

在每一轮算法开始时的满足的条件

- 查早算法 `data[i]`
  - `data[0,i]` 中都没找到目标（循环不变量） 

> 循环体：维持循环不变量，如果循环不变量发生改变，那么循环状态将会改变



# 基础排序算法



### 选择排序法

依次将最小的元素取出

```java
	// 借助额外空间实现
	public Integer[] sort(Integer[] data) {

        Integer[] sortedArr = new Integer[data.length];
        int minIndex = 0;

        for (int i = 0; i < sortedArr.length; i++) {
            minIndex = 0;
            for (int j = 0; j < data.length; j++) {
                if (data[minIndex] > data[j]) {
                    minIndex = j;
                    break;
                }
            }

            sortedArr[i] = data[minIndex];
            data = compact(data, minIndex);
        }

       return sortedArr;
    }

    private Integer[] compact(Integer[] data, int index) {
        Integer[] compactedArr = new Integer[data.length - 1];
        int cur = 0;

        for (int i = 0; i < index; i++) {
            if (index != i) {
                compactedArr[i] = data[cur++];
            }
        }

        for (int i = index; i < compactedArr.length; i++) {
            index++;
            compactedArr[i] = data[index];
        }

        return compactedArr;
    }

	// 原地排序实现
	public void sort(int[] data) {
        int minIndex = 0;

        for (int i = 0; i < data.length; i++) {
    	    minIndex = i;
        for (int j = i + 1; j < data.length; j++) {
            if (data[minIndex] > data[j]){
                minIndex = j;
            }
            swap(data,i,minIndex);
        }
    }
```

> 使用带约束的泛型来扩展使用范围：
>
> 实现 `<E extends Comparable<E>>`
